# app/ui/dashboard.py
from __future__ import annotations

import json
import os
import sys
from pathlib import Path
from typing import Any, Dict, Optional

import requests
import streamlit as st

# --- robust src-layout bootstrap (works no matter where you run from) ---
REPO_ROOT = Path(__file__).resolve().parents[2]  # app/ui/dashboard.py -> repo root
SRC = REPO_ROOT / "src"
if str(SRC) not in sys.path:
    sys.path.insert(0, str(SRC))

DEFAULT_API = os.getenv("API_URL", "http://127.0.0.1:8000")


def _safe_json(resp: requests.Response) -> Dict[str, Any]:
    try:
        return resp.json()
    except Exception:
        return {"_raw": resp.text[:1500], "_status_code": resp.status_code}


def _api_get(api_base: str, path: str, timeout: int = 20) -> requests.Response:
    return requests.get(f"{api_base}{path}", timeout=timeout)


def _api_post(api_base: str, path: str, timeout: int = 60, **kwargs) -> requests.Response:
    return requests.post(f"{api_base}{path}", timeout=timeout, **kwargs)


def _exists(path: Optional[str]) -> bool:
    return bool(path) and Path(path).exists()


def _download(label: str, path: str, mime: str) -> None:
    p = Path(path)
    if not p.exists():
        st.warning(f"Missing file: {path}")
        return
    st.download_button(label, data=p.read_bytes(), file_name=p.name, mime=mime, use_container_width=True)


def main() -> None:
    st.set_page_config(page_title="CareerAgent-AI Mission Control", layout="wide")
    st.title("CareerAgent-AI ‚Äî Mission Control (One-Click Automation)")
    st.caption("Upload resume ‚Üí autonomous ingestion + discovery + ranking ‚Üí HITL approvals ‚Üí drafts + dossier downloads")

    api_base = st.sidebar.text_input("API Base URL", value=DEFAULT_API)

    # Health indicator
    st.sidebar.divider()
    st.sidebar.subheader("Backend")
    try:
        h = _api_get(api_base, "/health", timeout=3)
        if h.status_code == 200:
            st.sidebar.success("üü¢ API Online")
        else:
            st.sidebar.warning(f"üü† API issue ({h.status_code})")
    except Exception as e:
        st.sidebar.error("üî¥ API Offline")
        st.sidebar.caption(str(e))
        st.stop()

    # Upload + preferences (NO resume textarea)
    st.sidebar.divider()
    st.sidebar.subheader("Resume Upload")
    resume_file = st.sidebar.file_uploader("Upload Resume (PDF/TXT/DOCX)", type=["pdf", "txt", "docx"])

    st.sidebar.subheader("Preferences")
    target_role = st.sidebar.text_input("Target role", value="Data Scientist")
    country = st.sidebar.text_input("Country", value="US")
    location = st.sidebar.text_input("Location", value="United States")
    remote = st.sidebar.checkbox("Remote preferred", value=True)
    wfo_ok = st.sidebar.checkbox("On-site/WFO acceptable", value=True)
    salary = st.sidebar.text_input("Salary target (optional)", value="")
    user_phone = st.sidebar.text_input("Phone for SMS (optional)", value="")

    st.sidebar.subheader("Autonomy Controls")
    discovery_threshold = st.sidebar.slider("Discovery confidence threshold", 0.50, 0.90, 0.70, 0.05)
    max_refinements = st.sidebar.slider("Max query refinements", 1, 5, 3, 1)

    run_btn = st.sidebar.button(
        "üöÄ RUN ONE-CLICK", type="primary", use_container_width=True, disabled=(resume_file is None)
    )

    st.sidebar.divider()
    st.sidebar.subheader("Existing Run")
    run_id_in = st.sidebar.text_input("Run ID", value=st.session_state.get("run_id", ""))

    # Start run
    if run_btn:
        prefs = {
            "target_role": target_role.strip() or "Data Scientist",
            "country": country.strip() or "US",
            "location": location.strip() or "United States",
            "remote": bool(remote),
            "wfo_ok": bool(wfo_ok),
            "salary": salary.strip(),
            "user_phone": user_phone.strip() or None,
            "discovery_threshold": float(discovery_threshold),
            "max_refinements": int(max_refinements),
        }

        files = {"resume": (resume_file.name, resume_file.getvalue())}
        data = {"preferences_json": json.dumps(prefs)}

        try:
            r = _api_post(api_base, "/analyze", files=files, data=data, timeout=120)
        except Exception as e:
            st.error(f"‚ùå API not reachable: {e}")
            st.stop()

        if r.status_code >= 400:
            st.error(f"/analyze failed: {r.status_code}\n\n{r.text[:1500]}")
            st.stop()

        out = _safe_json(r)
        st.session_state["run_id"] = out["run_id"]
        st.success(f"Run started: {out['run_id']} (status: {out.get('status')})")

    # Determine run_id
    run_id = st.session_state.get("run_id") or run_id_in.strip()
    if not run_id:
        st.info("Upload a resume and click RUN, or paste an existing run_id.")
        return

    # Poll state
    colA, colB, colC = st.columns([1, 1, 1])
    _ = st.button("üîÑ Refresh", use_container_width=True)

    try:
        r = _api_get(api_base, f"/status/{run_id}", timeout=20)
        if r.status_code != 200:
            st.warning(f"Run not found yet ({r.status_code}).")
            return
        state = _safe_json(r)
    except Exception as e:
        st.error(f"‚ùå API not reachable: {e}")
        return

    status = state.get("status", "unknown")
    meta = state.get("meta", {}) or {}
    feed = meta.get("live_feed", []) or []
    steps = state.get("steps", []) or []
    artifacts = state.get("artifacts", {}) or {}
    pending = meta.get("pending_action")

    with colA:
        st.metric("Run ID", run_id)
    with colB:
        st.metric("Status", status)
    with colC:
        st.metric("Pending", str(pending))

    total = max(1, len(steps))
    done = sum(1 for s in steps if s.get("finished_at_utc"))
    st.progress(done / total)

    left, right = st.columns([1.25, 0.75], vertical_alignment="top")

    with left:
        st.markdown("### Live Agent Feed")
        if not feed:
            st.info("No live feed yet.")
        else:
            for ev in feed[-140:]:
                st.write(f"**[{ev.get('layer')} {ev.get('agent')}]** {ev.get('message')}")

        with st.expander("Audit Trail (Steps)"):
            for s in steps:
                st.write(f"- [{s.get('layer_id')}] {s.get('tool_name')} | {s.get('status')} | {s.get('step_id')}")

    with right:
        st.markdown("### Key Scores")
        job_scores = meta.get("job_scores", {}) or {}
        if job_scores:
            jid, score = next(iter(job_scores.items()))
            pct = float(score) * 100.0
            st.metric("Top InterviewChance", f"{pct:.2f}%")
            st.progress(min(1.0, max(0.0, pct / 100.0)))
        else:
            st.caption("Scores not available yet.")

        st.markdown("### Downloads")
        zip_ref = artifacts.get("career_dossier_zip")
        pdf_ref = artifacts.get("xai_transparency_pdf")

        if zip_ref and _exists(zip_ref.get("path")):
            _download("Download Career Dossier (ZIP)", zip_ref["path"], "application/zip")
        else:
            st.caption("Dossier ZIP not ready.")

        if pdf_ref and _exists(pdf_ref.get("path")):
            _download("Download XAI Transparency (PDF)", pdf_ref["path"], "application/pdf")
        else:
            st.caption("XAI PDF not ready.")

    st.markdown("### Ranking")
    ranking_ref = artifacts.get("ranking")
    if ranking_ref and _exists(ranking_ref.get("path")):
        ranking = json.loads(Path(ranking_ref["path"]).read_text(encoding="utf-8"))
        st.dataframe(
            [
                {
                    "score_%": round(float(x.get("overall_match_percent", 0.0)), 2),
                    "role": x.get("role_title"),
                    "company": x.get("company"),
                    "url": x.get("url"),
                    "missing_required": ", ".join((x.get("missing_required_skills") or [])[:5]),
                }
                for x in ranking
            ],
            use_container_width=True,
        )
    else:
        st.caption("Ranking not available yet.")

    st.markdown("### Human-in-the-Loop Controls")
    if status == "needs_human_approval" and pending == "review_ranking":
        c1, c2 = st.columns(2)
        with c1:
            if st.button("‚úÖ Approve Ranking ‚Üí Generate Drafts", type="primary", use_container_width=True):
                _api_post(api_base, f"/action/{run_id}", json={"action_type": "approve_ranking", "payload": {}}, timeout=30)
                st.success("Approved. Draft generation started.")
        with c2:
            reason = st.text_input("Reason to refine ranking", value="")
            if st.button("‚ùå Reject Ranking ‚Üí Re-run Discovery", use_container_width=True):
                _api_post(api_base, f"/action/{run_id}", json={"action_type": "reject_ranking", "payload": {"reason": reason}}, timeout=30)
                st.warning("Rejected. Discovery refinement started.")

    if status == "needs_human_approval" and pending == "review_drafts":
        c1, c2 = st.columns(2)
        with c1:
            if st.button("‚úÖ Approve Drafts ‚Üí Submit (Simulated)", type="primary", use_container_width=True):
                _api_post(api_base, f"/action/{run_id}", json={"action_type": "approve_drafts", "payload": {}}, timeout=30)
                st.success("Approved. Submission started.")
        with c2:
            reason = st.text_input("Reason to revise drafts", value="")
            if st.button("‚ùå Reject Drafts ‚Üí Back to Ranking", use_container_width=True):
                _api_post(api_base, f"/action/{run_id}", json={"action_type": "reject_drafts", "payload": {"reason": reason}}, timeout=30)
                st.warning("Rejected drafts. Returning to ranking review.")

    with st.expander("Full State JSON"):
        st.json(state)


if __name__ == "__main__":
    main()